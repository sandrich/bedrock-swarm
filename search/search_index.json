{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Bedrock Swarm","text":"<p>Bedrock Swarm is a powerful framework for building multi-agent systems using AWS Bedrock. It provides a simple yet flexible API for creating and managing AI agents powered by various AWS Bedrock models.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Easy Agent Creation: Create AI agents with just a few lines of code</li> <li>AWS Bedrock Integration: Native support for AWS Bedrock models</li> <li>Multi-Agent Support: Build complex systems with multiple cooperating agents</li> <li>Extensible Tools: Add custom capabilities to your agents</li> <li>Memory Management: Built-in conversation memory management</li> <li>Async Support: Handle concurrent operations efficiently</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from bedrock_swarm import BedrockAgent, Agency\nfrom bedrock_swarm.config import AWSConfig\n\n# Configure AWS\nconfig = AWSConfig(region=\"us-west-2\")\n\n# Create agents\nanalyst = BedrockAgent(\n    name=\"analyst\",\n    model_id=\"anthropic.claude-v2\",\n    aws_config=config\n)\n\nresearcher = BedrockAgent(\n    name=\"researcher\",\n    model_id=\"anthropic.claude-v2\",\n    aws_config=config\n)\n\n# Create agency\nagency = Agency([analyst, researcher])\n\n# Execute tasks\nresult = await agency.execute(\"Analyze this dataset and prepare a report\")\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Install Bedrock Swarm using pip:</p> <pre><code>pip install bedrock-swarm\n</code></pre> <p>For development:</p> <pre><code>pip install bedrock-swarm[dev]\n</code></pre> <p>For documentation:</p> <pre><code>pip install bedrock-swarm[docs]\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Check out the Quick Start Guide for a more detailed introduction</li> <li>Learn about the core concepts in the User Guide</li> <li>Browse the API Reference for detailed documentation</li> <li>See Examples for practical use cases </li> </ul>"},{"location":"api/agents/","title":"Agents API Reference","text":""},{"location":"api/agents/#bedrockagent","title":"BedrockAgent","text":""},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent","title":"<code>bedrock_swarm.agents.base.BedrockAgent</code>","text":"<p>Base class for Bedrock-powered agents.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the agent</p> required <code>model_id</code> <code>str</code> <p>Bedrock model ID (e.g., anthropic.claude-v2)</p> required <code>aws_config</code> <code>AWSConfig</code> <p>AWS configuration</p> required <code>instructions</code> <code>Optional[str]</code> <p>System instructions for the agent</p> <code>None</code> <code>temperature</code> <code>Optional[float]</code> <p>Temperature for model inference</p> <code>None</code> <code>max_tokens</code> <code>Optional[int]</code> <p>Maximum tokens for model response</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidModelError</code> <p>If the model ID is not supported</p> <code>AWSConfigError</code> <p>If there is an error with AWS configuration</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>class BedrockAgent:\n    \"\"\"Base class for Bedrock-powered agents.\n\n    Args:\n        name (str): Name of the agent\n        model_id (str): Bedrock model ID (e.g., anthropic.claude-v2)\n        aws_config (AWSConfig): AWS configuration\n        instructions (Optional[str]): System instructions for the agent\n        temperature (Optional[float]): Temperature for model inference\n        max_tokens (Optional[int]): Maximum tokens for model response\n\n    Raises:\n        InvalidModelError: If the model ID is not supported\n        AWSConfigError: If there is an error with AWS configuration\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        model_id: str,\n        aws_config: AWSConfig,\n        instructions: Optional[str] = None,\n        temperature: Optional[float] = None,\n        max_tokens: Optional[int] = None\n    ):\n        self.name = name\n        self.model_id = model_id\n        self.instructions = instructions\n        self.temperature = self._validate_temperature(temperature)\n        self.max_tokens = max_tokens or 1000\n        self._tools: Dict[str, BaseTool] = {}\n\n        # Validate model ID\n        self._validate_model_id()\n\n        try:\n            # Create a session with the profile\n            session = boto3.Session(\n                region_name=aws_config.region,\n                profile_name=aws_config.profile\n            )\n\n            # Create the client using the session\n            self.bedrock = session.client(\n                'bedrock-runtime',\n                endpoint_url=aws_config.endpoint_url\n            )\n\n            # Register built-in tools\n            from ..tools.web import WebSearchTool\n            if \"WebSearchTool\" not in ToolFactory._tool_types:\n                ToolFactory.register_tool_type(WebSearchTool)\n\n        except (BotoCoreError, ClientError) as e:\n            raise AWSConfigError(f\"Failed to initialize AWS client: {str(e)}\")\n\n    def _validate_model_id(self) -&gt; None:\n        \"\"\"Validate the model ID.\n\n        Raises:\n            InvalidModelError: If the model ID is not supported\n        \"\"\"\n        model_family = next((family for family in SUPPORTED_MODELS if self.model_id.startswith(family)), None)\n        if not model_family:\n            supported = \", \".join(SUPPORTED_MODELS.keys())\n            raise InvalidModelError(\n                f\"Unsupported model family in '{self.model_id}'. \"\n                f\"Supported families are: {supported}\"\n            )\n\n        version = self.model_id[len(model_family)+1:]\n        if version not in SUPPORTED_MODELS[model_family][\"versions\"]:\n            versions = \", \".join(SUPPORTED_MODELS[model_family][\"versions\"])\n            raise InvalidModelError(\n                f\"Unsupported version '{version}' for model family '{model_family}'. \"\n                f\"Supported versions are: {versions}\"\n            )\n\n    def _validate_temperature(self, temperature: Optional[float]) -&gt; float:\n        \"\"\"Validate and return the temperature value.\n\n        Args:\n            temperature (Optional[float]): Temperature value to validate\n\n        Returns:\n            float: Validated temperature value\n\n        Raises:\n            ValueError: If temperature is invalid\n        \"\"\"\n        if temperature is None:\n            return 0.7\n        if not 0 &lt;= temperature &lt;= 1:\n            raise ValueError(\"Temperature must be between 0 and 1\")\n        return temperature\n\n    @property\n    def tools(self) -&gt; List[BaseTool]:\n        \"\"\"Get all tools as a list.\n\n        Returns:\n            List[BaseTool]: List of all tools\n        \"\"\"\n        return list(self._tools.values())\n\n    def add_tool(self, tool: Union[BaseTool, str], **kwargs) -&gt; BaseTool:\n        \"\"\"Add a tool to the agent.\n\n        Args:\n            tool (Union[BaseTool, str]): Tool instance or tool type name\n            **kwargs: Tool configuration parameters if creating from type name\n\n        Returns:\n            BaseTool: Added tool instance\n\n        Raises:\n            ToolError: If tool creation fails or tool already exists\n        \"\"\"\n        if isinstance(tool, str):\n            # Create tool from type name\n            tool = ToolFactory.create_tool(tool, **kwargs)\n        elif not isinstance(tool, BaseTool):\n            raise ToolError(f\"Invalid tool type: {type(tool)}\")\n\n        # Add tool to collection\n        self._tools[tool.name] = tool\n        return tool\n\n    def get_tool(self, tool_name: str) -&gt; BaseTool:\n        \"\"\"Get a tool by name.\n\n        Args:\n            tool_name (str): Name of the tool to get\n\n        Returns:\n            BaseTool: Tool if found\n\n        Raises:\n            ToolError: If tool is not found\n        \"\"\"\n        if tool_name not in self._tools:\n            raise ToolError(f\"Tool '{tool_name}' not found\")\n        return self._tools[tool_name]\n\n    def get_tools(self) -&gt; Dict[str, BaseTool]:\n        \"\"\"Get all tools.\n\n        Returns:\n            Dict[str, BaseTool]: Dictionary of tool name to tool instance\n        \"\"\"\n        return self._tools.copy()\n\n    def remove_tool(self, tool_name: str) -&gt; None:\n        \"\"\"Remove a tool by name.\n\n        Args:\n            tool_name (str): Name of the tool to remove\n\n        Raises:\n            ToolError: If tool is not found\n        \"\"\"\n        if tool_name not in self._tools:\n            raise ToolError(f\"Tool '{tool_name}' not found\")\n        del self._tools[tool_name]\n\n    def clear_tools(self) -&gt; None:\n        \"\"\"Remove all tools.\"\"\"\n        self._tools.clear()\n\n    def _format_claude_prompt(self, message: str) -&gt; str:\n        \"\"\"Format request for Claude models.\n\n        Args:\n            message (str): Message to format\n\n        Returns:\n            str: Formatted prompt\n        \"\"\"\n        system = f\"System: {self.instructions}\\n\\n\" if self.instructions else \"\"\n        return f\"{system}Human: {message}\\n\\nAssistant:\"\n\n    def _format_titan_prompt(self, message: str) -&gt; Dict[str, Any]:\n        \"\"\"Format request for Titan models.\"\"\"\n        system = f\"System: {self.instructions}\\n\\n\" if self.instructions else \"\"\n        prompt = f\"{system}Human: {message}\\nAssistant:\"\n\n        return {\n            \"inputText\": prompt,\n            \"textGenerationConfig\": {\n                \"temperature\": self.temperature,\n                \"maxTokenCount\": self.max_tokens\n            }\n        }\n\n    def _format_jurassic_prompt(self, message: str) -&gt; Dict[str, Any]:\n        \"\"\"Format request for Jurassic models.\"\"\"\n        system = f\"{self.instructions}\\n\\n\" if self.instructions else \"\"\n        prompt = f\"{system}{message}\"\n\n        return {\n            \"prompt\": prompt,\n            \"temperature\": self.temperature,\n            \"maxTokens\": self.max_tokens,\n            \"stopSequences\": [\"Human:\", \"Assistant:\"]\n        }\n\n    def _format_cohere_prompt(self, message: str) -&gt; Dict[str, Any]:\n        \"\"\"Format request for Cohere models.\"\"\"\n        system = f\"{self.instructions}\\n\\n\" if self.instructions else \"\"\n        prompt = f\"{system}{message}\"\n\n        return {\n            \"prompt\": prompt,\n            \"temperature\": self.temperature,\n            \"max_tokens\": self.max_tokens,\n            \"return_likelihoods\": \"NONE\"\n        }\n\n    def _format_request_body(self, message: str) -&gt; Dict[str, Any]:\n        \"\"\"Format request body based on model type.\n\n        Args:\n            message (str): Message to format\n\n        Returns:\n            Dict[str, Any]: Formatted request body\n        \"\"\"\n        if self.model_id.startswith(\"anthropic.claude\"):\n            # Format for Claude models\n            request_body = {\n                \"prompt\": self._format_claude_prompt(message),\n                \"max_tokens\": self.max_tokens,\n                \"temperature\": self.temperature,\n                \"anthropic_version\": \"bedrock-2023-05-31\"\n            }\n\n            # Add tool schema if tools are configured\n            if self._tools:\n                request_body[\"tools\"] = [\n                    tool.get_schema() for tool in self._tools.values()\n                ]\n\n        elif self.model_id.startswith(\"amazon.titan\"):\n            # Format for Titan models\n            request_body = {\n                \"inputText\": self._format_titan_prompt(message),\n                \"textGenerationConfig\": {\n                    \"maxTokenCount\": self.max_tokens,\n                    \"temperature\": self.temperature,\n                    \"topP\": 1\n                }\n            }\n        elif self.model_id.startswith(\"ai21.j2\"):\n            # Format for Jurassic models\n            request_body = self._format_jurassic_prompt(message)\n        elif self.model_id.startswith(\"cohere.command\"):\n            # Format for Cohere models\n            request_body = self._format_cohere_prompt(message)\n        else:\n            raise ValueError(f\"Unsupported model type: {self.model_id}\")\n\n        return request_body\n\n    def _parse_response(self, response: Dict[str, Any]) -&gt; str:\n        \"\"\"Parse response based on model type.\n\n        Args:\n            response (Dict[str, Any]): Response from the model\n\n        Returns:\n            str: Parsed response text\n\n        Raises:\n            ResponseParsingError: If response cannot be parsed\n        \"\"\"\n        try:\n            if self.model_id.startswith(\"anthropic.claude\"):\n                if \"completion\" not in response:\n                    raise ResponseParsingError(\"Missing 'completion' in response\")\n                return response[\"completion\"]\n            elif self.model_id.startswith(\"amazon.titan\"):\n                if \"results\" not in response or not response[\"results\"]:\n                    raise ResponseParsingError(\"Missing 'results' in response\")\n                if \"outputText\" not in response[\"results\"][0]:\n                    raise ResponseParsingError(\"Missing 'outputText' in response\")\n                return response[\"results\"][0][\"outputText\"]\n            elif self.model_id.startswith(\"ai21.j2\"):\n                if \"completions\" not in response or not response[\"completions\"]:\n                    raise ResponseParsingError(\"Missing 'completions' in response\")\n                if \"data\" not in response[\"completions\"][0]:\n                    raise ResponseParsingError(\"Missing 'data' in response\")\n                if \"text\" not in response[\"completions\"][0][\"data\"]:\n                    raise ResponseParsingError(\"Missing 'text' in response\")\n                return response[\"completions\"][0][\"data\"][\"text\"]\n            elif self.model_id.startswith(\"cohere.command\"):\n                if \"generations\" not in response or not response[\"generations\"]:\n                    raise ResponseParsingError(\"Missing 'generations' in response\")\n                if \"text\" not in response[\"generations\"][0]:\n                    raise ResponseParsingError(\"Missing 'text' in response\")\n                return response[\"generations\"][0][\"text\"]\n            else:\n                # This should never happen due to _validate_model_id\n                for key in [\"completion\", \"text\", \"output\", \"response\"]:\n                    if key in response:\n                        return response[key]\n                raise ResponseParsingError(f\"Unable to parse response: {response}\")\n        except (KeyError, IndexError, TypeError) as e:\n            raise ResponseParsingError(\n                f\"Failed to parse response for model {self.model_id}: {str(e)}\\n\"\n                f\"Response: {response}\"\n            )\n\n    def _get_tool_schemas(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get schemas for all tools.\"\"\"\n        return [tool.get_schema() for tool in self._tools.values()]\n\n    async def _execute_tool(self, tool_name: str, parameters: Dict[str, Any]) -&gt; str:\n        \"\"\"Execute a tool by name.\n\n        Args:\n            tool_name (str): Name of the tool to execute\n            parameters (Dict[str, Any]): Tool parameters\n\n        Returns:\n            str: Tool execution result\n\n        Raises:\n            ToolNotFoundError: If tool is not found\n            ToolExecutionError: If tool execution fails\n        \"\"\"\n        if tool_name not in self._tools:\n            raise ToolNotFoundError(f\"Tool '{tool_name}' not found\")\n\n        try:\n            return await self._tools[tool_name].execute(**parameters)\n        except Exception as e:\n            raise ToolExecutionError(f\"Failed to execute tool '{tool_name}': {str(e)}\")\n\n    async def process_message(self, message: str) -&gt; str:\n        \"\"\"Process a message and return the response.\n\n        Args:\n            message (str): Message to process\n\n        Returns:\n            str: Response from the model\n        \"\"\"\n        # Format request body based on model type\n        request_body = self._format_request_body(message)\n\n        # Invoke model\n        response = await self._invoke_model(request_body)\n\n        # Parse response based on model type\n        if self.model_id.startswith(\"anthropic.claude\"):\n            # Extract tool calls if present\n            tool_calls = self._extract_tool_calls(response)\n\n            # Execute tool calls if present\n            if tool_calls:\n                for tool_call in tool_calls:\n                    await self._execute_tool_call(tool_call)\n\n        return self._extract_response_text(response)\n\n    async def _invoke_model(self, request_body: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Invoke the Bedrock model.\n\n        Args:\n            request_body (Dict[str, Any]): Request body for the model\n\n        Returns:\n            Dict[str, Any]: Model response\n\n        Raises:\n            ModelInvokeError: If model invocation fails\n            ResponseParsingError: If response cannot be parsed\n            ToolExecutionError: If tool execution fails\n            ToolNotFoundError: If a tool is not found\n        \"\"\"\n        try:\n            # Invoke the model\n            response = self.bedrock.invoke_model(\n                modelId=self.model_id,\n                body=json.dumps(request_body)\n            )\n\n            # Parse response\n            response_body = json.loads(response[\"body\"].read())\n\n            return response_body\n\n        except (BotoCoreError, ClientError) as e:\n            raise ModelInvokeError(f\"Failed to invoke model: {str(e)}\")\n        except json.JSONDecodeError as e:\n            raise ResponseParsingError(f\"Failed to decode response: {str(e)}\")\n\n    def _extract_tool_calls(self, response: Dict[str, Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Extract tool calls from the model response.\n\n        Args:\n            response (Dict[str, Any]): Model response\n\n        Returns:\n            List[Dict[str, Any]]: List of tool calls\n        \"\"\"\n        if self.model_id.startswith(\"anthropic.claude\"):\n            if \"tool_calls\" in response:\n                return response[\"tool_calls\"]\n        return []\n\n    async def _execute_tool_call(self, tool_call: Dict[str, Any]) -&gt; str:\n        \"\"\"Execute a tool call.\n\n        Args:\n            tool_call (Dict[str, Any]): Tool call to execute\n\n        Returns:\n            str: Tool execution result\n\n        Raises:\n            ToolNotFoundError: If tool is not found\n            ToolExecutionError: If tool execution fails\n        \"\"\"\n        if \"function\" not in tool_call:\n            raise ToolExecutionError(\"Missing 'function' in tool call\")\n\n        func = tool_call[\"function\"]\n        return await self._execute_tool(func[\"name\"], json.loads(func[\"arguments\"]))\n\n    def _extract_response_text(self, response: Dict[str, Any]) -&gt; str:\n        \"\"\"Extract response text from the model response.\n\n        Args:\n            response (Dict[str, Any]): Model response\n\n        Returns:\n            str: Extracted response text\n        \"\"\"\n        if self.model_id.startswith(\"anthropic.claude\"):\n            return self._parse_response(response)\n        elif self.model_id.startswith(\"amazon.titan\"):\n            return self._parse_response(response)\n        elif self.model_id.startswith(\"ai21.j2\"):\n            return self._parse_response(response)\n        elif self.model_id.startswith(\"cohere.command\"):\n            return self._parse_response(response)\n        else:\n            # This should never happen due to _validate_model_id\n            for key in [\"completion\", \"text\", \"output\", \"response\"]:\n                if key in response:\n                    return response[key]\n            raise ResponseParsingError(f\"Unable to parse response: {response}\") \n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent-attributes","title":"Attributes","text":""},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent.tools","title":"<code>tools</code>  <code>property</code>","text":"<p>Get all tools as a list.</p> <p>Returns:</p> Type Description <code>List[BaseTool]</code> <p>List[BaseTool]: List of all tools</p>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent-functions","title":"Functions","text":""},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._execute_tool","title":"<code>_execute_tool(tool_name, parameters)</code>  <code>async</code>","text":"<p>Execute a tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool to execute</p> required <code>parameters</code> <code>Dict[str, Any]</code> <p>Tool parameters</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Tool execution result</p> <p>Raises:</p> Type Description <code>ToolNotFoundError</code> <p>If tool is not found</p> <code>ToolExecutionError</code> <p>If tool execution fails</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>async def _execute_tool(self, tool_name: str, parameters: Dict[str, Any]) -&gt; str:\n    \"\"\"Execute a tool by name.\n\n    Args:\n        tool_name (str): Name of the tool to execute\n        parameters (Dict[str, Any]): Tool parameters\n\n    Returns:\n        str: Tool execution result\n\n    Raises:\n        ToolNotFoundError: If tool is not found\n        ToolExecutionError: If tool execution fails\n    \"\"\"\n    if tool_name not in self._tools:\n        raise ToolNotFoundError(f\"Tool '{tool_name}' not found\")\n\n    try:\n        return await self._tools[tool_name].execute(**parameters)\n    except Exception as e:\n        raise ToolExecutionError(f\"Failed to execute tool '{tool_name}': {str(e)}\")\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._execute_tool_call","title":"<code>_execute_tool_call(tool_call)</code>  <code>async</code>","text":"<p>Execute a tool call.</p> <p>Parameters:</p> Name Type Description Default <code>tool_call</code> <code>Dict[str, Any]</code> <p>Tool call to execute</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Tool execution result</p> <p>Raises:</p> Type Description <code>ToolNotFoundError</code> <p>If tool is not found</p> <code>ToolExecutionError</code> <p>If tool execution fails</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>async def _execute_tool_call(self, tool_call: Dict[str, Any]) -&gt; str:\n    \"\"\"Execute a tool call.\n\n    Args:\n        tool_call (Dict[str, Any]): Tool call to execute\n\n    Returns:\n        str: Tool execution result\n\n    Raises:\n        ToolNotFoundError: If tool is not found\n        ToolExecutionError: If tool execution fails\n    \"\"\"\n    if \"function\" not in tool_call:\n        raise ToolExecutionError(\"Missing 'function' in tool call\")\n\n    func = tool_call[\"function\"]\n    return await self._execute_tool(func[\"name\"], json.loads(func[\"arguments\"]))\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._extract_response_text","title":"<code>_extract_response_text(response)</code>","text":"<p>Extract response text from the model response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Dict[str, Any]</code> <p>Model response</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extracted response text</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def _extract_response_text(self, response: Dict[str, Any]) -&gt; str:\n    \"\"\"Extract response text from the model response.\n\n    Args:\n        response (Dict[str, Any]): Model response\n\n    Returns:\n        str: Extracted response text\n    \"\"\"\n    if self.model_id.startswith(\"anthropic.claude\"):\n        return self._parse_response(response)\n    elif self.model_id.startswith(\"amazon.titan\"):\n        return self._parse_response(response)\n    elif self.model_id.startswith(\"ai21.j2\"):\n        return self._parse_response(response)\n    elif self.model_id.startswith(\"cohere.command\"):\n        return self._parse_response(response)\n    else:\n        # This should never happen due to _validate_model_id\n        for key in [\"completion\", \"text\", \"output\", \"response\"]:\n            if key in response:\n                return response[key]\n        raise ResponseParsingError(f\"Unable to parse response: {response}\") \n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._extract_tool_calls","title":"<code>_extract_tool_calls(response)</code>","text":"<p>Extract tool calls from the model response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Dict[str, Any]</code> <p>Model response</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of tool calls</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def _extract_tool_calls(self, response: Dict[str, Any]) -&gt; List[Dict[str, Any]]:\n    \"\"\"Extract tool calls from the model response.\n\n    Args:\n        response (Dict[str, Any]): Model response\n\n    Returns:\n        List[Dict[str, Any]]: List of tool calls\n    \"\"\"\n    if self.model_id.startswith(\"anthropic.claude\"):\n        if \"tool_calls\" in response:\n            return response[\"tool_calls\"]\n    return []\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._format_claude_prompt","title":"<code>_format_claude_prompt(message)</code>","text":"<p>Format request for Claude models.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message to format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted prompt</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def _format_claude_prompt(self, message: str) -&gt; str:\n    \"\"\"Format request for Claude models.\n\n    Args:\n        message (str): Message to format\n\n    Returns:\n        str: Formatted prompt\n    \"\"\"\n    system = f\"System: {self.instructions}\\n\\n\" if self.instructions else \"\"\n    return f\"{system}Human: {message}\\n\\nAssistant:\"\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._format_cohere_prompt","title":"<code>_format_cohere_prompt(message)</code>","text":"<p>Format request for Cohere models.</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def _format_cohere_prompt(self, message: str) -&gt; Dict[str, Any]:\n    \"\"\"Format request for Cohere models.\"\"\"\n    system = f\"{self.instructions}\\n\\n\" if self.instructions else \"\"\n    prompt = f\"{system}{message}\"\n\n    return {\n        \"prompt\": prompt,\n        \"temperature\": self.temperature,\n        \"max_tokens\": self.max_tokens,\n        \"return_likelihoods\": \"NONE\"\n    }\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._format_jurassic_prompt","title":"<code>_format_jurassic_prompt(message)</code>","text":"<p>Format request for Jurassic models.</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def _format_jurassic_prompt(self, message: str) -&gt; Dict[str, Any]:\n    \"\"\"Format request for Jurassic models.\"\"\"\n    system = f\"{self.instructions}\\n\\n\" if self.instructions else \"\"\n    prompt = f\"{system}{message}\"\n\n    return {\n        \"prompt\": prompt,\n        \"temperature\": self.temperature,\n        \"maxTokens\": self.max_tokens,\n        \"stopSequences\": [\"Human:\", \"Assistant:\"]\n    }\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._format_request_body","title":"<code>_format_request_body(message)</code>","text":"<p>Format request body based on model type.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message to format</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Formatted request body</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def _format_request_body(self, message: str) -&gt; Dict[str, Any]:\n    \"\"\"Format request body based on model type.\n\n    Args:\n        message (str): Message to format\n\n    Returns:\n        Dict[str, Any]: Formatted request body\n    \"\"\"\n    if self.model_id.startswith(\"anthropic.claude\"):\n        # Format for Claude models\n        request_body = {\n            \"prompt\": self._format_claude_prompt(message),\n            \"max_tokens\": self.max_tokens,\n            \"temperature\": self.temperature,\n            \"anthropic_version\": \"bedrock-2023-05-31\"\n        }\n\n        # Add tool schema if tools are configured\n        if self._tools:\n            request_body[\"tools\"] = [\n                tool.get_schema() for tool in self._tools.values()\n            ]\n\n    elif self.model_id.startswith(\"amazon.titan\"):\n        # Format for Titan models\n        request_body = {\n            \"inputText\": self._format_titan_prompt(message),\n            \"textGenerationConfig\": {\n                \"maxTokenCount\": self.max_tokens,\n                \"temperature\": self.temperature,\n                \"topP\": 1\n            }\n        }\n    elif self.model_id.startswith(\"ai21.j2\"):\n        # Format for Jurassic models\n        request_body = self._format_jurassic_prompt(message)\n    elif self.model_id.startswith(\"cohere.command\"):\n        # Format for Cohere models\n        request_body = self._format_cohere_prompt(message)\n    else:\n        raise ValueError(f\"Unsupported model type: {self.model_id}\")\n\n    return request_body\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._format_titan_prompt","title":"<code>_format_titan_prompt(message)</code>","text":"<p>Format request for Titan models.</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def _format_titan_prompt(self, message: str) -&gt; Dict[str, Any]:\n    \"\"\"Format request for Titan models.\"\"\"\n    system = f\"System: {self.instructions}\\n\\n\" if self.instructions else \"\"\n    prompt = f\"{system}Human: {message}\\nAssistant:\"\n\n    return {\n        \"inputText\": prompt,\n        \"textGenerationConfig\": {\n            \"temperature\": self.temperature,\n            \"maxTokenCount\": self.max_tokens\n        }\n    }\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._get_tool_schemas","title":"<code>_get_tool_schemas()</code>","text":"<p>Get schemas for all tools.</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def _get_tool_schemas(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get schemas for all tools.\"\"\"\n    return [tool.get_schema() for tool in self._tools.values()]\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._invoke_model","title":"<code>_invoke_model(request_body)</code>  <code>async</code>","text":"<p>Invoke the Bedrock model.</p> <p>Parameters:</p> Name Type Description Default <code>request_body</code> <code>Dict[str, Any]</code> <p>Request body for the model</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Model response</p> <p>Raises:</p> Type Description <code>ModelInvokeError</code> <p>If model invocation fails</p> <code>ResponseParsingError</code> <p>If response cannot be parsed</p> <code>ToolExecutionError</code> <p>If tool execution fails</p> <code>ToolNotFoundError</code> <p>If a tool is not found</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>async def _invoke_model(self, request_body: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Invoke the Bedrock model.\n\n    Args:\n        request_body (Dict[str, Any]): Request body for the model\n\n    Returns:\n        Dict[str, Any]: Model response\n\n    Raises:\n        ModelInvokeError: If model invocation fails\n        ResponseParsingError: If response cannot be parsed\n        ToolExecutionError: If tool execution fails\n        ToolNotFoundError: If a tool is not found\n    \"\"\"\n    try:\n        # Invoke the model\n        response = self.bedrock.invoke_model(\n            modelId=self.model_id,\n            body=json.dumps(request_body)\n        )\n\n        # Parse response\n        response_body = json.loads(response[\"body\"].read())\n\n        return response_body\n\n    except (BotoCoreError, ClientError) as e:\n        raise ModelInvokeError(f\"Failed to invoke model: {str(e)}\")\n    except json.JSONDecodeError as e:\n        raise ResponseParsingError(f\"Failed to decode response: {str(e)}\")\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._parse_response","title":"<code>_parse_response(response)</code>","text":"<p>Parse response based on model type.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Dict[str, Any]</code> <p>Response from the model</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Parsed response text</p> <p>Raises:</p> Type Description <code>ResponseParsingError</code> <p>If response cannot be parsed</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def _parse_response(self, response: Dict[str, Any]) -&gt; str:\n    \"\"\"Parse response based on model type.\n\n    Args:\n        response (Dict[str, Any]): Response from the model\n\n    Returns:\n        str: Parsed response text\n\n    Raises:\n        ResponseParsingError: If response cannot be parsed\n    \"\"\"\n    try:\n        if self.model_id.startswith(\"anthropic.claude\"):\n            if \"completion\" not in response:\n                raise ResponseParsingError(\"Missing 'completion' in response\")\n            return response[\"completion\"]\n        elif self.model_id.startswith(\"amazon.titan\"):\n            if \"results\" not in response or not response[\"results\"]:\n                raise ResponseParsingError(\"Missing 'results' in response\")\n            if \"outputText\" not in response[\"results\"][0]:\n                raise ResponseParsingError(\"Missing 'outputText' in response\")\n            return response[\"results\"][0][\"outputText\"]\n        elif self.model_id.startswith(\"ai21.j2\"):\n            if \"completions\" not in response or not response[\"completions\"]:\n                raise ResponseParsingError(\"Missing 'completions' in response\")\n            if \"data\" not in response[\"completions\"][0]:\n                raise ResponseParsingError(\"Missing 'data' in response\")\n            if \"text\" not in response[\"completions\"][0][\"data\"]:\n                raise ResponseParsingError(\"Missing 'text' in response\")\n            return response[\"completions\"][0][\"data\"][\"text\"]\n        elif self.model_id.startswith(\"cohere.command\"):\n            if \"generations\" not in response or not response[\"generations\"]:\n                raise ResponseParsingError(\"Missing 'generations' in response\")\n            if \"text\" not in response[\"generations\"][0]:\n                raise ResponseParsingError(\"Missing 'text' in response\")\n            return response[\"generations\"][0][\"text\"]\n        else:\n            # This should never happen due to _validate_model_id\n            for key in [\"completion\", \"text\", \"output\", \"response\"]:\n                if key in response:\n                    return response[key]\n            raise ResponseParsingError(f\"Unable to parse response: {response}\")\n    except (KeyError, IndexError, TypeError) as e:\n        raise ResponseParsingError(\n            f\"Failed to parse response for model {self.model_id}: {str(e)}\\n\"\n            f\"Response: {response}\"\n        )\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._validate_model_id","title":"<code>_validate_model_id()</code>","text":"<p>Validate the model ID.</p> <p>Raises:</p> Type Description <code>InvalidModelError</code> <p>If the model ID is not supported</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def _validate_model_id(self) -&gt; None:\n    \"\"\"Validate the model ID.\n\n    Raises:\n        InvalidModelError: If the model ID is not supported\n    \"\"\"\n    model_family = next((family for family in SUPPORTED_MODELS if self.model_id.startswith(family)), None)\n    if not model_family:\n        supported = \", \".join(SUPPORTED_MODELS.keys())\n        raise InvalidModelError(\n            f\"Unsupported model family in '{self.model_id}'. \"\n            f\"Supported families are: {supported}\"\n        )\n\n    version = self.model_id[len(model_family)+1:]\n    if version not in SUPPORTED_MODELS[model_family][\"versions\"]:\n        versions = \", \".join(SUPPORTED_MODELS[model_family][\"versions\"])\n        raise InvalidModelError(\n            f\"Unsupported version '{version}' for model family '{model_family}'. \"\n            f\"Supported versions are: {versions}\"\n        )\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent._validate_temperature","title":"<code>_validate_temperature(temperature)</code>","text":"<p>Validate and return the temperature value.</p> <p>Parameters:</p> Name Type Description Default <code>temperature</code> <code>Optional[float]</code> <p>Temperature value to validate</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Validated temperature value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If temperature is invalid</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def _validate_temperature(self, temperature: Optional[float]) -&gt; float:\n    \"\"\"Validate and return the temperature value.\n\n    Args:\n        temperature (Optional[float]): Temperature value to validate\n\n    Returns:\n        float: Validated temperature value\n\n    Raises:\n        ValueError: If temperature is invalid\n    \"\"\"\n    if temperature is None:\n        return 0.7\n    if not 0 &lt;= temperature &lt;= 1:\n        raise ValueError(\"Temperature must be between 0 and 1\")\n    return temperature\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent.add_tool","title":"<code>add_tool(tool, **kwargs)</code>","text":"<p>Add a tool to the agent.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>Union[BaseTool, str]</code> <p>Tool instance or tool type name</p> required <code>**kwargs</code> <p>Tool configuration parameters if creating from type name</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>BaseTool</code> <code>BaseTool</code> <p>Added tool instance</p> <p>Raises:</p> Type Description <code>ToolError</code> <p>If tool creation fails or tool already exists</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def add_tool(self, tool: Union[BaseTool, str], **kwargs) -&gt; BaseTool:\n    \"\"\"Add a tool to the agent.\n\n    Args:\n        tool (Union[BaseTool, str]): Tool instance or tool type name\n        **kwargs: Tool configuration parameters if creating from type name\n\n    Returns:\n        BaseTool: Added tool instance\n\n    Raises:\n        ToolError: If tool creation fails or tool already exists\n    \"\"\"\n    if isinstance(tool, str):\n        # Create tool from type name\n        tool = ToolFactory.create_tool(tool, **kwargs)\n    elif not isinstance(tool, BaseTool):\n        raise ToolError(f\"Invalid tool type: {type(tool)}\")\n\n    # Add tool to collection\n    self._tools[tool.name] = tool\n    return tool\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent.clear_tools","title":"<code>clear_tools()</code>","text":"<p>Remove all tools.</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def clear_tools(self) -&gt; None:\n    \"\"\"Remove all tools.\"\"\"\n    self._tools.clear()\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent.get_tool","title":"<code>get_tool(tool_name)</code>","text":"<p>Get a tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool to get</p> required <p>Returns:</p> Name Type Description <code>BaseTool</code> <code>BaseTool</code> <p>Tool if found</p> <p>Raises:</p> Type Description <code>ToolError</code> <p>If tool is not found</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def get_tool(self, tool_name: str) -&gt; BaseTool:\n    \"\"\"Get a tool by name.\n\n    Args:\n        tool_name (str): Name of the tool to get\n\n    Returns:\n        BaseTool: Tool if found\n\n    Raises:\n        ToolError: If tool is not found\n    \"\"\"\n    if tool_name not in self._tools:\n        raise ToolError(f\"Tool '{tool_name}' not found\")\n    return self._tools[tool_name]\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent.get_tools","title":"<code>get_tools()</code>","text":"<p>Get all tools.</p> <p>Returns:</p> Type Description <code>Dict[str, BaseTool]</code> <p>Dict[str, BaseTool]: Dictionary of tool name to tool instance</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def get_tools(self) -&gt; Dict[str, BaseTool]:\n    \"\"\"Get all tools.\n\n    Returns:\n        Dict[str, BaseTool]: Dictionary of tool name to tool instance\n    \"\"\"\n    return self._tools.copy()\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent.process_message","title":"<code>process_message(message)</code>  <code>async</code>","text":"<p>Process a message and return the response.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message to process</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Response from the model</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>async def process_message(self, message: str) -&gt; str:\n    \"\"\"Process a message and return the response.\n\n    Args:\n        message (str): Message to process\n\n    Returns:\n        str: Response from the model\n    \"\"\"\n    # Format request body based on model type\n    request_body = self._format_request_body(message)\n\n    # Invoke model\n    response = await self._invoke_model(request_body)\n\n    # Parse response based on model type\n    if self.model_id.startswith(\"anthropic.claude\"):\n        # Extract tool calls if present\n        tool_calls = self._extract_tool_calls(response)\n\n        # Execute tool calls if present\n        if tool_calls:\n            for tool_call in tool_calls:\n                await self._execute_tool_call(tool_call)\n\n    return self._extract_response_text(response)\n</code></pre>"},{"location":"api/agents/#bedrock_swarm.agents.base.BedrockAgent.remove_tool","title":"<code>remove_tool(tool_name)</code>","text":"<p>Remove a tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool to remove</p> required <p>Raises:</p> Type Description <code>ToolError</code> <p>If tool is not found</p> Source code in <code>bedrock_swarm/agents/base.py</code> <pre><code>def remove_tool(self, tool_name: str) -&gt; None:\n    \"\"\"Remove a tool by name.\n\n    Args:\n        tool_name (str): Name of the tool to remove\n\n    Raises:\n        ToolError: If tool is not found\n    \"\"\"\n    if tool_name not in self._tools:\n        raise ToolError(f\"Tool '{tool_name}' not found\")\n    del self._tools[tool_name]\n</code></pre>"},{"location":"api/agents/#supported-models","title":"Supported Models","text":"<p>The following AWS Bedrock models are supported:</p>"},{"location":"api/agents/#anthropic-claude","title":"Anthropic Claude","text":"<ul> <li><code>anthropic.claude-v1</code></li> <li><code>anthropic.claude-v2</code></li> <li><code>anthropic.claude-v2:1</code></li> <li><code>anthropic.claude-instant-v1</code></li> </ul>"},{"location":"api/agents/#amazon-titan","title":"Amazon Titan","text":"<ul> <li><code>amazon.titan-text-express-v1</code></li> <li><code>amazon.titan-text-lite-v1</code></li> </ul>"},{"location":"api/agents/#ai21-jurassic","title":"AI21 Jurassic","text":"<ul> <li><code>ai21.j2-mid-v1</code></li> <li><code>ai21.j2-ultra-v1</code></li> </ul>"},{"location":"api/agents/#cohere-command","title":"Cohere Command","text":"<ul> <li><code>cohere.command-text-v14</code></li> </ul>"},{"location":"api/agents/#examples","title":"Examples","text":""},{"location":"api/agents/#basic-usage","title":"Basic Usage","text":"<pre><code>from bedrock_swarm import BedrockAgent\nfrom bedrock_swarm.config import AWSConfig\n\n# Create agent\nagent = BedrockAgent(\n    name=\"assistant\",\n    model_id=\"anthropic.claude-v2\",\n    aws_config=AWSConfig(region=\"us-west-2\"),\n    instructions=\"You are a helpful AI assistant.\",\n    temperature=0.7,\n    max_tokens=1000\n)\n\n# Process messages\nresponse = await agent.process_message(\"Hello!\")\n</code></pre>"},{"location":"api/agents/#with-tools","title":"With Tools","text":"<pre><code># Add built-in tool\nagent.add_tool(\"WebSearchTool\")\n\n# Add custom tool\nfrom bedrock_swarm.tools import BaseTool\n\nclass CustomTool(BaseTool):\n    name = \"custom_tool\"\n    description = \"Custom tool description\"\n\n    async def execute(self, **kwargs):\n        return \"Result\"\n\nagent.add_tool(CustomTool())\n</code></pre>"},{"location":"api/agents/#with-memory","title":"With Memory","text":"<pre><code>from bedrock_swarm.memory import SimpleMemory\n\n# Create agent with memory\nagent = BedrockAgent(\n    name=\"assistant\",\n    model_id=\"anthropic.claude-v2\",\n    aws_config=config,\n    memory=SimpleMemory()\n)\n\n# Process messages\nawait agent.process_message(\"Hello!\")\nmessages = await agent.memory.get_messages()\n</code></pre>"},{"location":"api/agents/#error-handling","title":"Error Handling","text":"<pre><code>from bedrock_swarm.exceptions import ModelInvokeError, ToolError\n\ntry:\n    response = await agent.process_message(\"Use the tool\")\nexcept ModelInvokeError as e:\n    print(f\"Model error: {e}\")\nexcept ToolError as e:\n    print(f\"Tool error: {e}\")\n</code></pre>"},{"location":"api/memory/","title":"Memory API Reference","text":""},{"location":"api/memory/#basememory","title":"BaseMemory","text":""},{"location":"api/memory/#bedrock_swarm.memory.base.BaseMemory","title":"<code>bedrock_swarm.memory.base.BaseMemory</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for memory systems.</p> <p>Memory systems are responsible for storing and retrieving conversation history and other relevant information for agents.</p> Source code in <code>bedrock_swarm/memory/base.py</code> <pre><code>class BaseMemory(ABC):\n    \"\"\"Base class for memory systems.\n\n    Memory systems are responsible for storing and retrieving conversation history\n    and other relevant information for agents.\n    \"\"\"\n\n    @abstractmethod\n    async def add_message(self, message: Message) -&gt; None:\n        \"\"\"Add a message to memory.\n\n        Args:\n            message (Message): Message to add\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get_messages(\n        self,\n        limit: Optional[int] = None,\n        before: Optional[datetime] = None,\n        after: Optional[datetime] = None,\n        role: Optional[str] = None\n    ) -&gt; List[Message]:\n        \"\"\"Get messages from memory.\n\n        Args:\n            limit (Optional[int]): Maximum number of messages to return\n            before (Optional[datetime]): Get messages before this time\n            after (Optional[datetime]): Get messages after this time\n            role (Optional[str]): Filter by sender role\n\n        Returns:\n            List[Message]: List of messages matching criteria\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def clear(self) -&gt; None:\n        \"\"\"Clear all messages from memory.\"\"\"\n        pass\n</code></pre>"},{"location":"api/memory/#bedrock_swarm.memory.base.BaseMemory-functions","title":"Functions","text":""},{"location":"api/memory/#bedrock_swarm.memory.base.BaseMemory.add_message","title":"<code>add_message(message)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Add a message to memory.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>Message to add</p> required Source code in <code>bedrock_swarm/memory/base.py</code> <pre><code>@abstractmethod\nasync def add_message(self, message: Message) -&gt; None:\n    \"\"\"Add a message to memory.\n\n    Args:\n        message (Message): Message to add\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/memory/#bedrock_swarm.memory.base.BaseMemory.clear","title":"<code>clear()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Clear all messages from memory.</p> Source code in <code>bedrock_swarm/memory/base.py</code> <pre><code>@abstractmethod\nasync def clear(self) -&gt; None:\n    \"\"\"Clear all messages from memory.\"\"\"\n    pass\n</code></pre>"},{"location":"api/memory/#bedrock_swarm.memory.base.BaseMemory.get_messages","title":"<code>get_messages(limit=None, before=None, after=None, role=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get messages from memory.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>Optional[int]</code> <p>Maximum number of messages to return</p> <code>None</code> <code>before</code> <code>Optional[datetime]</code> <p>Get messages before this time</p> <code>None</code> <code>after</code> <code>Optional[datetime]</code> <p>Get messages after this time</p> <code>None</code> <code>role</code> <code>Optional[str]</code> <p>Filter by sender role</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Message]</code> <p>List[Message]: List of messages matching criteria</p> Source code in <code>bedrock_swarm/memory/base.py</code> <pre><code>@abstractmethod\nasync def get_messages(\n    self,\n    limit: Optional[int] = None,\n    before: Optional[datetime] = None,\n    after: Optional[datetime] = None,\n    role: Optional[str] = None\n) -&gt; List[Message]:\n    \"\"\"Get messages from memory.\n\n    Args:\n        limit (Optional[int]): Maximum number of messages to return\n        before (Optional[datetime]): Get messages before this time\n        after (Optional[datetime]): Get messages after this time\n        role (Optional[str]): Filter by sender role\n\n    Returns:\n        List[Message]: List of messages matching criteria\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/memory/#simplememory","title":"SimpleMemory","text":""},{"location":"api/memory/#bedrock_swarm.memory.base.SimpleMemory","title":"<code>bedrock_swarm.memory.base.SimpleMemory</code>","text":"<p>               Bases: <code>BaseMemory</code></p> <p>Simple in-memory implementation of BaseMemory.</p> Source code in <code>bedrock_swarm/memory/base.py</code> <pre><code>class SimpleMemory(BaseMemory):\n    \"\"\"Simple in-memory implementation of BaseMemory.\"\"\"\n\n    def __init__(self):\n        self._messages: List[Message] = []\n\n    async def add_message(self, message: Message) -&gt; None:\n        self._messages.append(message)\n\n    async def get_messages(\n        self,\n        limit: Optional[int] = None,\n        before: Optional[datetime] = None,\n        after: Optional[datetime] = None,\n        role: Optional[str] = None\n    ) -&gt; List[Message]:\n        messages = self._messages\n\n        if before:\n            messages = [m for m in messages if m.timestamp &lt; before]\n\n        if after:\n            messages = [m for m in messages if m.timestamp &gt; after]\n\n        if role:\n            messages = [m for m in messages if m.role == role]\n\n        if limit:\n            messages = messages[-limit:]\n\n        return messages\n\n    async def clear(self) -&gt; None:\n        self._messages.clear() \n</code></pre>"},{"location":"api/memory/#message","title":"Message","text":""},{"location":"api/memory/#bedrock_swarm.memory.base.Message","title":"<code>bedrock_swarm.memory.base.Message</code>  <code>dataclass</code>","text":"<p>A message in the conversation history.</p> <p>Attributes:</p> Name Type Description <code>role</code> <code>str</code> <p>Role of the sender (e.g., \"human\", \"assistant\", \"system\")</p> <code>content</code> <code>str</code> <p>Message content</p> <code>timestamp</code> <code>datetime</code> <p>When the message was sent</p> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Additional message metadata</p> Source code in <code>bedrock_swarm/memory/base.py</code> <pre><code>@dataclass\nclass Message:\n    \"\"\"A message in the conversation history.\n\n    Attributes:\n        role (str): Role of the sender (e.g., \"human\", \"assistant\", \"system\")\n        content (str): Message content\n        timestamp (datetime): When the message was sent\n        metadata (Optional[Dict[str, Any]]): Additional message metadata\n    \"\"\"\n    role: str\n    content: str\n    timestamp: datetime\n    metadata: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/memory/#using-memory","title":"Using Memory","text":""},{"location":"api/memory/#basic-usage","title":"Basic Usage","text":"<pre><code>from bedrock_swarm.memory import SimpleMemory, Message\nfrom datetime import datetime\n\n# Create memory system\nmemory = SimpleMemory()\n\n# Add messages\nawait memory.add_message(Message(\n    role=\"human\",\n    content=\"Hello!\",\n    timestamp=datetime.now()\n))\n\nawait memory.add_message(Message(\n    role=\"assistant\",\n    content=\"Hi there!\",\n    timestamp=datetime.now()\n))\n\n# Retrieve messages\nmessages = await memory.get_messages()\nfor msg in messages:\n    print(f\"{msg.role}: {msg.content}\")\n</code></pre>"},{"location":"api/memory/#filtering-messages","title":"Filtering Messages","text":"<pre><code>from datetime import datetime, timedelta\n\n# Get recent messages\nnow = datetime.now()\nrecent = await memory.get_messages(\n    after=now - timedelta(minutes=5)\n)\n\n# Get messages by role\nhuman_msgs = await memory.get_messages(role=\"human\")\n\n# Get limited number of messages\nlast_3 = await memory.get_messages(limit=3)\n</code></pre>"},{"location":"api/memory/#with-metadata","title":"With Metadata","text":"<pre><code># Add message with metadata\nawait memory.add_message(Message(\n    role=\"system\",\n    content=\"Configuration updated\",\n    timestamp=datetime.now(),\n    metadata={\n        \"config_type\": \"model\",\n        \"changes\": [\"temperature\", \"max_tokens\"]\n    }\n))\n\n# Filter by examining metadata\nmessages = await memory.get_messages()\nconfig_msgs = [\n    msg for msg in messages\n    if msg.metadata and msg.metadata.get(\"config_type\") == \"model\"\n]\n</code></pre>"},{"location":"api/memory/#creating-custom-memory-systems","title":"Creating Custom Memory Systems","text":"<p>To create a custom memory system, inherit from <code>BaseMemory</code>:</p> <pre><code>from bedrock_swarm.memory import BaseMemory, Message\nfrom typing import List, Optional\nfrom datetime import datetime\n\nclass CustomMemory(BaseMemory):\n    def __init__(self):\n        self._messages = []\n\n    async def add_message(self, message: Message) -&gt; None:\n        # Add custom processing here\n        self._messages.append(message)\n\n    async def get_messages(\n        self,\n        limit: Optional[int] = None,\n        before: Optional[datetime] = None,\n        after: Optional[datetime] = None,\n        role: Optional[str] = None\n    ) -&gt; List[Message]:\n        messages = self._messages\n\n        # Apply filters\n        if before:\n            messages = [m for m in messages if m.timestamp &lt; before]\n        if after:\n            messages = [m for m in messages if m.timestamp &gt; after]\n        if role:\n            messages = [m for m in messages if m.role == role]\n        if limit:\n            messages = messages[-limit:]\n\n        return messages\n\n    async def clear(self) -&gt; None:\n        self._messages.clear()\n</code></pre>"},{"location":"api/memory/#best-practices","title":"Best Practices","text":"<ol> <li>Memory Management</li> <li>Clear memory periodically to prevent excessive memory usage</li> <li>Use appropriate filters when retrieving messages</li> <li> <p>Include relevant metadata for better organization</p> </li> <li> <p>Message Structure</p> </li> <li>Use appropriate roles (human/assistant/system)</li> <li>Include accurate timestamps</li> <li> <p>Add helpful metadata when needed</p> </li> <li> <p>Custom Implementations</p> </li> <li>Consider persistence requirements</li> <li>Implement efficient filtering</li> <li>Handle concurrent access if needed </li> </ol>"},{"location":"api/tools/","title":"Tools API Reference","text":""},{"location":"api/tools/#basetool","title":"BaseTool","text":""},{"location":"api/tools/#bedrock_swarm.tools.base.BaseTool","title":"<code>bedrock_swarm.tools.base.BaseTool</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for tools that can be used by agents.</p> <p>All tools must implement: - name: Tool name - description: Tool description - get_schema: Method to get JSON schema - execute: Method to execute the tool</p> Source code in <code>bedrock_swarm/tools/base.py</code> <pre><code>class BaseTool(ABC):\n    \"\"\"Base class for tools that can be used by agents.\n\n    All tools must implement:\n    - name: Tool name\n    - description: Tool description\n    - get_schema: Method to get JSON schema\n    - execute: Method to execute the tool\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"Get tool name.\"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def description(self) -&gt; str:\n        \"\"\"Get tool description.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Get JSON schema for the tool.\n\n        Returns:\n            Dict[str, Any]: Tool schema\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def execute(self, **kwargs: Any) -&gt; str:\n        \"\"\"Execute the tool with given parameters.\n\n        Args:\n            **kwargs: Tool parameters\n\n        Returns:\n            str: Tool execution result\n        \"\"\"\n        pass \n</code></pre>"},{"location":"api/tools/#bedrock_swarm.tools.base.BaseTool-attributes","title":"Attributes","text":""},{"location":"api/tools/#bedrock_swarm.tools.base.BaseTool.description","title":"<code>description</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get tool description.</p>"},{"location":"api/tools/#bedrock_swarm.tools.base.BaseTool.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get tool name.</p>"},{"location":"api/tools/#bedrock_swarm.tools.base.BaseTool-functions","title":"Functions","text":""},{"location":"api/tools/#bedrock_swarm.tools.base.BaseTool.execute","title":"<code>execute(**kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Execute the tool with given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Tool parameters</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Tool execution result</p> Source code in <code>bedrock_swarm/tools/base.py</code> <pre><code>@abstractmethod\nasync def execute(self, **kwargs: Any) -&gt; str:\n    \"\"\"Execute the tool with given parameters.\n\n    Args:\n        **kwargs: Tool parameters\n\n    Returns:\n        str: Tool execution result\n    \"\"\"\n    pass \n</code></pre>"},{"location":"api/tools/#bedrock_swarm.tools.base.BaseTool.get_schema","title":"<code>get_schema()</code>  <code>abstractmethod</code>","text":"<p>Get JSON schema for the tool.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Tool schema</p> Source code in <code>bedrock_swarm/tools/base.py</code> <pre><code>@abstractmethod\ndef get_schema(self) -&gt; Dict[str, Any]:\n    \"\"\"Get JSON schema for the tool.\n\n    Returns:\n        Dict[str, Any]: Tool schema\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/tools/#websearchtool","title":"WebSearchTool","text":""},{"location":"api/tools/#bedrock_swarm.tools.web.WebSearchTool","title":"<code>bedrock_swarm.tools.web.WebSearchTool</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for performing web searches using DuckDuckGo.</p> <p>This tool uses the DuckDuckGo API to perform searches, providing reliable and efficient access to web search results.</p> Source code in <code>bedrock_swarm/tools/web.py</code> <pre><code>class WebSearchTool(BaseTool):\n    \"\"\"Tool for performing web searches using DuckDuckGo.\n\n    This tool uses the DuckDuckGo API to perform searches,\n    providing reliable and efficient access to web search results.\n    \"\"\"\n\n    def __init__(self):\n        self._ddgs = DDGS()\n\n    @property\n    def name(self) -&gt; str:\n        return \"web_search\"\n\n    @property\n    def description(self) -&gt; str:\n        return \"Search the web for information on a given query using DuckDuckGo\"\n\n    def get_schema(self) -&gt; Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"query\": {\n                        \"type\": \"string\",\n                        \"description\": \"The search query\"\n                    },\n                    \"num_results\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Number of results to return\",\n                        \"default\": 5\n                    }\n                },\n                \"required\": [\"query\"]\n            }\n        }\n\n    async def execute(self, query: str, num_results: int = 5) -&gt; str:\n        \"\"\"Execute web search using DuckDuckGo.\n\n        Args:\n            query (str): Search query\n            num_results (int): Number of results to return\n\n        Returns:\n            str: Search results formatted as a string\n        \"\"\"\n        try:\n            # Perform the search\n            results = list(self._ddgs.text(\n                query,\n                max_results=num_results\n            ))\n\n            if not results:\n                return \"No results found\"\n\n            # Format results\n            formatted_results = []\n            for i, result in enumerate(results, 1):\n                title = result.get('title', 'No title')\n                link = result.get('link', 'No link')\n                snippet = result.get('body', 'No description available')\n                formatted_results.append(f\"{i}. {title}\\n   {link}\\n   {snippet}\\n\")\n\n            return \"\\n\".join(formatted_results)\n\n        except Exception as e:\n            return f\"Error during search: {str(e)}\" \n</code></pre>"},{"location":"api/tools/#bedrock_swarm.tools.web.WebSearchTool-functions","title":"Functions","text":""},{"location":"api/tools/#bedrock_swarm.tools.web.WebSearchTool.execute","title":"<code>execute(query, num_results=5)</code>  <code>async</code>","text":"<p>Execute web search using DuckDuckGo.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>num_results</code> <code>int</code> <p>Number of results to return</p> <code>5</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Search results formatted as a string</p> Source code in <code>bedrock_swarm/tools/web.py</code> <pre><code>async def execute(self, query: str, num_results: int = 5) -&gt; str:\n    \"\"\"Execute web search using DuckDuckGo.\n\n    Args:\n        query (str): Search query\n        num_results (int): Number of results to return\n\n    Returns:\n        str: Search results formatted as a string\n    \"\"\"\n    try:\n        # Perform the search\n        results = list(self._ddgs.text(\n            query,\n            max_results=num_results\n        ))\n\n        if not results:\n            return \"No results found\"\n\n        # Format results\n        formatted_results = []\n        for i, result in enumerate(results, 1):\n            title = result.get('title', 'No title')\n            link = result.get('link', 'No link')\n            snippet = result.get('body', 'No description available')\n            formatted_results.append(f\"{i}. {title}\\n   {link}\\n   {snippet}\\n\")\n\n        return \"\\n\".join(formatted_results)\n\n    except Exception as e:\n        return f\"Error during search: {str(e)}\" \n</code></pre>"},{"location":"api/tools/#toolfactory","title":"ToolFactory","text":""},{"location":"api/tools/#bedrock_swarm.tools.factory.ToolFactory","title":"<code>bedrock_swarm.tools.factory.ToolFactory</code>","text":"<p>Factory class for creating and managing tools.</p> <p>This class provides a centralized way to create and manage tools. It maintains a registry of available tool types and their instances.</p> Source code in <code>bedrock_swarm/tools/factory.py</code> <pre><code>class ToolFactory:\n    \"\"\"Factory class for creating and managing tools.\n\n    This class provides a centralized way to create and manage tools.\n    It maintains a registry of available tool types and their instances.\n    \"\"\"\n\n    _tool_types: Dict[str, Type[BaseTool]] = {}\n    _tool_instances: Dict[str, BaseTool] = {}\n\n    @classmethod\n    def register_tool_type(cls, tool_type: Type[BaseTool]) -&gt; None:\n        \"\"\"Register a tool type.\n\n        Args:\n            tool_type (Type[BaseTool]): Tool type to register\n\n        Raises:\n            ToolError: If tool type is already registered\n        \"\"\"\n        tool_name = tool_type.__name__\n        if tool_name in cls._tool_types:\n            raise ToolError(f\"Tool type '{tool_name}' is already registered\")\n        cls._tool_types[tool_name] = tool_type\n\n    @classmethod\n    def create_tool(cls, tool_type_name: str, **kwargs) -&gt; BaseTool:\n        \"\"\"Create a tool instance.\n\n        Args:\n            tool_type_name (str): Name of the tool type to create\n            **kwargs: Tool configuration parameters\n\n        Returns:\n            BaseTool: Created tool instance\n\n        Raises:\n            ToolError: If tool type is not registered\n        \"\"\"\n        if tool_type_name not in cls._tool_types:\n            raise ToolError(f\"Tool type '{tool_type_name}' is not registered\")\n\n        tool_type = cls._tool_types[tool_type_name]\n        tool = tool_type(**kwargs)\n\n        # Store the instance if it's not already stored\n        if tool.name not in cls._tool_instances:\n            cls._tool_instances[tool.name] = tool\n\n        return tool\n\n    @classmethod\n    def get_tool(cls, tool_name: str) -&gt; Optional[BaseTool]:\n        \"\"\"Get a tool instance by name.\n\n        Args:\n            tool_name (str): Name of the tool to get\n\n        Returns:\n            Optional[BaseTool]: Tool instance if found, None otherwise\n        \"\"\"\n        return cls._tool_instances.get(tool_name)\n\n    @classmethod\n    def get_all_tools(cls) -&gt; List[BaseTool]:\n        \"\"\"Get all registered tool instances.\n\n        Returns:\n            List[BaseTool]: List of all tool instances\n        \"\"\"\n        return list(cls._tool_instances.values())\n\n    @classmethod\n    def clear(cls) -&gt; None:\n        \"\"\"Clear all registered tool types and instances.\"\"\"\n        cls._tool_types.clear()\n        cls._tool_instances.clear()\n</code></pre>"},{"location":"api/tools/#bedrock_swarm.tools.factory.ToolFactory-functions","title":"Functions","text":""},{"location":"api/tools/#bedrock_swarm.tools.factory.ToolFactory.clear","title":"<code>clear()</code>  <code>classmethod</code>","text":"<p>Clear all registered tool types and instances.</p> Source code in <code>bedrock_swarm/tools/factory.py</code> <pre><code>@classmethod\ndef clear(cls) -&gt; None:\n    \"\"\"Clear all registered tool types and instances.\"\"\"\n    cls._tool_types.clear()\n    cls._tool_instances.clear()\n</code></pre>"},{"location":"api/tools/#bedrock_swarm.tools.factory.ToolFactory.create_tool","title":"<code>create_tool(tool_type_name, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a tool instance.</p> <p>Parameters:</p> Name Type Description Default <code>tool_type_name</code> <code>str</code> <p>Name of the tool type to create</p> required <code>**kwargs</code> <p>Tool configuration parameters</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>BaseTool</code> <code>BaseTool</code> <p>Created tool instance</p> <p>Raises:</p> Type Description <code>ToolError</code> <p>If tool type is not registered</p> Source code in <code>bedrock_swarm/tools/factory.py</code> <pre><code>@classmethod\ndef create_tool(cls, tool_type_name: str, **kwargs) -&gt; BaseTool:\n    \"\"\"Create a tool instance.\n\n    Args:\n        tool_type_name (str): Name of the tool type to create\n        **kwargs: Tool configuration parameters\n\n    Returns:\n        BaseTool: Created tool instance\n\n    Raises:\n        ToolError: If tool type is not registered\n    \"\"\"\n    if tool_type_name not in cls._tool_types:\n        raise ToolError(f\"Tool type '{tool_type_name}' is not registered\")\n\n    tool_type = cls._tool_types[tool_type_name]\n    tool = tool_type(**kwargs)\n\n    # Store the instance if it's not already stored\n    if tool.name not in cls._tool_instances:\n        cls._tool_instances[tool.name] = tool\n\n    return tool\n</code></pre>"},{"location":"api/tools/#bedrock_swarm.tools.factory.ToolFactory.get_all_tools","title":"<code>get_all_tools()</code>  <code>classmethod</code>","text":"<p>Get all registered tool instances.</p> <p>Returns:</p> Type Description <code>List[BaseTool]</code> <p>List[BaseTool]: List of all tool instances</p> Source code in <code>bedrock_swarm/tools/factory.py</code> <pre><code>@classmethod\ndef get_all_tools(cls) -&gt; List[BaseTool]:\n    \"\"\"Get all registered tool instances.\n\n    Returns:\n        List[BaseTool]: List of all tool instances\n    \"\"\"\n    return list(cls._tool_instances.values())\n</code></pre>"},{"location":"api/tools/#bedrock_swarm.tools.factory.ToolFactory.get_tool","title":"<code>get_tool(tool_name)</code>  <code>classmethod</code>","text":"<p>Get a tool instance by name.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool to get</p> required <p>Returns:</p> Type Description <code>Optional[BaseTool]</code> <p>Optional[BaseTool]: Tool instance if found, None otherwise</p> Source code in <code>bedrock_swarm/tools/factory.py</code> <pre><code>@classmethod\ndef get_tool(cls, tool_name: str) -&gt; Optional[BaseTool]:\n    \"\"\"Get a tool instance by name.\n\n    Args:\n        tool_name (str): Name of the tool to get\n\n    Returns:\n        Optional[BaseTool]: Tool instance if found, None otherwise\n    \"\"\"\n    return cls._tool_instances.get(tool_name)\n</code></pre>"},{"location":"api/tools/#bedrock_swarm.tools.factory.ToolFactory.register_tool_type","title":"<code>register_tool_type(tool_type)</code>  <code>classmethod</code>","text":"<p>Register a tool type.</p> <p>Parameters:</p> Name Type Description Default <code>tool_type</code> <code>Type[BaseTool]</code> <p>Tool type to register</p> required <p>Raises:</p> Type Description <code>ToolError</code> <p>If tool type is already registered</p> Source code in <code>bedrock_swarm/tools/factory.py</code> <pre><code>@classmethod\ndef register_tool_type(cls, tool_type: Type[BaseTool]) -&gt; None:\n    \"\"\"Register a tool type.\n\n    Args:\n        tool_type (Type[BaseTool]): Tool type to register\n\n    Raises:\n        ToolError: If tool type is already registered\n    \"\"\"\n    tool_name = tool_type.__name__\n    if tool_name in cls._tool_types:\n        raise ToolError(f\"Tool type '{tool_name}' is already registered\")\n    cls._tool_types[tool_name] = tool_type\n</code></pre>"},{"location":"api/tools/#creating-custom-tools","title":"Creating Custom Tools","text":"<p>To create a custom tool, inherit from <code>BaseTool</code> and implement the required methods:</p> <pre><code>from bedrock_swarm.tools import BaseTool\nfrom typing import Dict, Any\n\nclass CustomTool(BaseTool):\n    @property\n    def name(self) -&gt; str:\n        return \"custom_tool\"\n\n    @property\n    def description(self) -&gt; str:\n        return \"Description of what the tool does\"\n\n    def get_schema(self) -&gt; Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"param1\": {\n                        \"type\": \"string\",\n                        \"description\": \"First parameter\"\n                    },\n                    \"param2\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Second parameter\"\n                    }\n                },\n                \"required\": [\"param1\"]\n            }\n        }\n\n    async def execute(self, param1: str, param2: int = 0) -&gt; str:\n        # Implement tool functionality\n        result = f\"Processed {param1} with {param2}\"\n        return result\n</code></pre>"},{"location":"api/tools/#using-tools","title":"Using Tools","text":""},{"location":"api/tools/#registering-tools","title":"Registering Tools","text":"<pre><code>from bedrock_swarm.tools import ToolFactory\n\n# Register a custom tool type\nToolFactory.register_tool_type(CustomTool)\n\n# Create tool instance\ntool = ToolFactory.create_tool(\"CustomTool\")\n</code></pre>"},{"location":"api/tools/#adding-tools-to-agents","title":"Adding Tools to Agents","text":"<pre><code># Add by tool type name\nagent.add_tool(\"WebSearchTool\")\n\n# Add tool instance\ncustom_tool = CustomTool()\nagent.add_tool(custom_tool)\n</code></pre>"},{"location":"api/tools/#tool-management","title":"Tool Management","text":"<pre><code># Get tool by name\ntool = agent.get_tool(\"custom_tool\")\n\n# Remove tool\nagent.remove_tool(\"custom_tool\")\n\n# Clear all tools\nagent.clear_tools()\n</code></pre>"},{"location":"api/tools/#built-in-tools","title":"Built-in Tools","text":""},{"location":"api/tools/#websearchtool_1","title":"WebSearchTool","text":"<p>The <code>WebSearchTool</code> provides web search capabilities using DuckDuckGo:</p> <pre><code>from bedrock_swarm.tools import WebSearchTool\n\n# Create and configure tool\nsearch_tool = WebSearchTool()\n\n# Add to agent\nagent.add_tool(search_tool)\n\n# Use in queries\nresponse = await agent.process_message(\n    \"What are the latest developments in quantum computing?\"\n)\n</code></pre>"},{"location":"api/tools/#parameters","title":"Parameters","text":"<ul> <li><code>query</code> (str): The search query</li> <li><code>num_results</code> (int, optional): Number of results to return (default: 5)</li> </ul>"},{"location":"api/tools/#example-response","title":"Example Response","text":"<pre><code>1. Latest Quantum Computing Breakthrough\n   https://example.com/article1\n   Description of the breakthrough...\n\n2. Quantum Computing Research Update\n   https://example.com/article2\n   Recent developments in the field...\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or higher</li> <li>AWS account with Bedrock access</li> <li>AWS credentials configured</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<pre><code># Basic installation\npip install bedrock-swarm\n\n# With development dependencies\npip install bedrock-swarm[dev]\n\n# With documentation dependencies\npip install bedrock-swarm[docs]\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/yourusername/bedrock-swarm.git\ncd bedrock-swarm\npip install -e \".[dev,docs]\"\n</code></pre>"},{"location":"getting-started/installation/#aws-configuration","title":"AWS Configuration","text":"<ol> <li>Configure your AWS credentials:</li> </ol> <pre><code>aws configure\n</code></pre> <p>Or set environment variables:</p> <pre><code>export AWS_ACCESS_KEY_ID=your_access_key\nexport AWS_SECRET_ACCESS_KEY=your_secret_key\nexport AWS_REGION=us-west-2\n</code></pre> <ol> <li>Ensure you have access to AWS Bedrock and the required models:</li> <li>Anthropic Claude (recommended)</li> <li>Amazon Titan</li> <li>AI21 Jurassic</li> <li>Cohere Command</li> </ol>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<pre><code>from bedrock_swarm import BedrockAgent\nfrom bedrock_swarm.config import AWSConfig\n\n# Create a config\nconfig = AWSConfig(region=\"us-west-2\")\n\n# Create an agent\nagent = BedrockAgent(\n    name=\"test_agent\",\n    model_id=\"anthropic.claude-v2\",\n    aws_config=config\n)\n\n# Test the agent\nresponse = await agent.process_message(\"Hello!\")\nprint(response)\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Follow the Quick Start Guide to create your first agent</li> <li>Learn about Core Concepts</li> <li>Check out the Examples </li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with Bedrock Swarm by creating a simple multi-agent system.</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom bedrock_swarm import BedrockAgent\nfrom bedrock_swarm.config import AWSConfig\n\nasync def main():\n    # Configure AWS\n    config = AWSConfig(region=\"us-west-2\")\n\n    # Create an agent\n    agent = BedrockAgent(\n        name=\"assistant\",\n        model_id=\"anthropic.claude-v2\",\n        aws_config=config,\n        instructions=\"You are a helpful AI assistant.\"\n    )\n\n    # Process a message\n    response = await agent.process_message(\"What is AWS Bedrock?\")\n    print(response)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#adding-tools","title":"Adding Tools","text":"<p>Agents can be enhanced with tools for additional capabilities:</p> <pre><code># Add web search capability\nagent.add_tool(\"WebSearchTool\")\n\n# Process a message that might use the tool\nresponse = await agent.process_message(\n    \"What are the latest developments in quantum computing?\"\n)\n</code></pre>"},{"location":"getting-started/quickstart/#creating-a-multi-agent-system","title":"Creating a Multi-Agent System","text":"<pre><code>from bedrock_swarm import Agency\n\n# Create specialized agents\nresearcher = BedrockAgent(\n    name=\"researcher\",\n    model_id=\"anthropic.claude-v2\",\n    aws_config=config,\n    instructions=\"You are a researcher focused on gathering information.\"\n)\nresearcher.add_tool(\"WebSearchTool\")\n\nanalyst = BedrockAgent(\n    name=\"analyst\",\n    model_id=\"anthropic.claude-v2\",\n    aws_config=config,\n    instructions=\"You are an analyst who evaluates and summarizes information.\"\n)\n\n# Create an agency\nagency = Agency([researcher, analyst])\n\n# Execute a task\nresult = await agency.execute(\n    \"Research and analyze the impact of AI on healthcare\"\n)\n</code></pre>"},{"location":"getting-started/quickstart/#using-memory","title":"Using Memory","text":"<p>Agents can maintain conversation history:</p> <pre><code>from bedrock_swarm.memory import SimpleMemory\n\n# Create an agent with memory\nagent = BedrockAgent(\n    name=\"assistant\",\n    model_id=\"anthropic.claude-v2\",\n    aws_config=config,\n    memory=SimpleMemory()\n)\n\n# Messages will be stored in memory\nawait agent.process_message(\"Hello!\")\nawait agent.process_message(\"What did I say before?\")\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Core Concepts</li> <li>Explore Advanced Patterns</li> <li>Read the API Reference </li> </ul>"},{"location":"user-guide/core-concepts/","title":"Core Concepts","text":"<p>Bedrock Swarm is built around several key concepts that work together to create powerful multi-agent systems.</p>"},{"location":"user-guide/core-concepts/#agents","title":"Agents","text":"<p>Agents are the core building blocks of the system. Each agent is powered by an AWS Bedrock model and can:</p> <ul> <li>Process messages and generate responses</li> <li>Use tools to perform actions</li> <li>Maintain conversation memory</li> <li>Follow specific instructions</li> </ul> <pre><code>agent = BedrockAgent(\n    name=\"assistant\",\n    model_id=\"anthropic.claude-v2\",\n    aws_config=config,\n    instructions=\"You are a helpful AI assistant.\",\n    temperature=0.7,\n    max_tokens=1000\n)\n</code></pre>"},{"location":"user-guide/core-concepts/#agent-properties","title":"Agent Properties","text":"<ul> <li><code>name</code>: Unique identifier for the agent</li> <li><code>model_id</code>: AWS Bedrock model to use</li> <li><code>instructions</code>: System prompt/instructions for the agent</li> <li><code>temperature</code>: Controls response randomness (0-1)</li> <li><code>max_tokens</code>: Maximum response length</li> </ul>"},{"location":"user-guide/core-concepts/#tools","title":"Tools","text":"<p>Tools extend agents' capabilities by allowing them to perform specific actions:</p> <pre><code># Built-in tools\nagent.add_tool(\"WebSearchTool\")\n\n# Custom tools\nclass CustomTool(BaseTool):\n    @property\n    def name(self) -&gt; str:\n        return \"custom_tool\"\n\n    @property\n    def description(self) -&gt; str:\n        return \"Description of what the tool does\"\n\n    async def execute(self, **kwargs) -&gt; str:\n        # Tool implementation\n        return \"Result\"\n</code></pre>"},{"location":"user-guide/core-concepts/#tool-properties","title":"Tool Properties","text":"<ul> <li><code>name</code>: Unique identifier for the tool</li> <li><code>description</code>: What the tool does</li> <li><code>schema</code>: JSON schema defining parameters</li> <li><code>execute</code>: Implementation of the tool's functionality</li> </ul>"},{"location":"user-guide/core-concepts/#memory","title":"Memory","text":"<p>Memory systems allow agents to maintain context across conversations:</p> <pre><code>class CustomMemory(BaseMemory):\n    async def add_message(self, message: Message) -&gt; None:\n        # Store message\n        pass\n\n    async def get_messages(self) -&gt; List[Message]:\n        # Retrieve messages\n        pass\n\n    async def clear(self) -&gt; None:\n        # Clear memory\n        pass\n</code></pre>"},{"location":"user-guide/core-concepts/#message-properties","title":"Message Properties","text":"<ul> <li><code>role</code>: Who sent the message (human/assistant/system)</li> <li><code>content</code>: The message content</li> <li><code>timestamp</code>: When the message was sent</li> <li><code>metadata</code>: Additional information</li> </ul>"},{"location":"user-guide/core-concepts/#agency","title":"Agency","text":"<p>Agencies coordinate multiple agents to solve complex tasks:</p> <pre><code>agency = Agency([\n    researcher,\n    analyst,\n    writer\n])\n\n# Sequential execution\nresult = await agency.execute(task)\n\n# Parallel discussion\nhistory = await agency.discuss(topic)\n</code></pre>"},{"location":"user-guide/core-concepts/#agency-features","title":"Agency Features","text":"<ul> <li>Task distribution</li> <li>Agent coordination</li> <li>Result aggregation</li> <li>Multi-round discussions</li> </ul>"},{"location":"user-guide/core-concepts/#error-handling","title":"Error Handling","text":"<p>The library provides specific exceptions for different error cases:</p> <pre><code>try:\n    result = await agent.process_message(message)\nexcept ModelInvokeError:\n    # Handle model API errors\nexcept ToolError:\n    # Handle tool-related errors\nexcept ResponseParsingError:\n    # Handle response parsing errors\n</code></pre>"},{"location":"user-guide/core-concepts/#common-exceptions","title":"Common Exceptions","text":"<ul> <li><code>ModelInvokeError</code>: AWS Bedrock API errors</li> <li><code>ToolError</code>: Tool-related errors</li> <li><code>ToolNotFoundError</code>: Unknown tool requested</li> <li><code>ToolExecutionError</code>: Tool execution failed</li> <li><code>ResponseParsingError</code>: Invalid model response</li> </ul>"},{"location":"user-guide/core-concepts/#best-practices","title":"Best Practices","text":"<ol> <li>Agent Design</li> <li>Give clear, specific instructions</li> <li>Use appropriate temperature settings</li> <li> <p>Implement proper error handling</p> </li> <li> <p>Tool Implementation</p> </li> <li>Make tools focused and reusable</li> <li>Provide clear documentation</li> <li> <p>Handle errors gracefully</p> </li> <li> <p>Memory Management</p> </li> <li>Clear memory when appropriate</li> <li>Consider memory limitations</li> <li> <p>Use metadata for organization</p> </li> <li> <p>Agency Coordination</p> </li> <li>Define clear agent roles</li> <li>Break down complex tasks</li> <li>Monitor agent interactions </li> </ol>"}]}